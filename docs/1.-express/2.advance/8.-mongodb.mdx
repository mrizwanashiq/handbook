---
sidebar_position: 2
id: mongodb
title: MongoDB and Mongoose
# description: 
slug: mongodb
---

JavaScript is considered the [top web development](https://insights.stackoverflow.com/survey/2021#section-most-popular-technologies-programming-scripting-and-markup-languages) language today, running in millions of applications and websites. One of the building blocks for the JavaScript stack, in many of its variations, is REST API-based communication between the front-end and back-end tiers.

A popular way of implementing the REST API approach uses [Express JS](https://expressjs.com/) as the back-end web server and MongoDB as the document store. This concept easily maps MongoDB's document model to the REST API payloads which are JSON by nature.

This blog will help you learn how to connect your webserver to a database. First, we'll learn the basic concepts of MongoDB, and then we will create our web application. The application will enable us to add, edit, and delete students in a MongoDB database and show a list of students in the database in the browser.

## What is MongoDB?

* MongoDB is a cross-platform, document-oriented database that provides high performance and scalability. It works on the concepts of collection and document
* It is a NoSQL database and is written in C++
* To be able to use MongoDB, download the free MongoDB database from the [official website](https://www.mongodb.com/)
MongoDB works mainly on the two following concepts:

### Collection
A collection is a group of MongoDB documents; documents within a collection can contain different fields. Typically, all documents in a collection have a similar purpose.

### Document
A document is a set of key-value pairs. Documents have a dynamic schema, which means that documents in the same collection don't need to have the same set of fields or structures. Common fields in a collection's documents may hold different types of data.

## Why connect Express with MongoDB?

All modern applications rely on big data, fast-feature development, and flexible deployment. Traditional databases support these requirements.

The primary purpose of building MongoDB is:
* Scalability
* Performance
* High Availability
* Scaling from single server deployments to large complex multi-site architectures

## What is Mongoose?
### How MongoDB Works

To understand what is Mongoose we first need to understand in general terms how MongoDB works. The basic unit of data we can save in MongoDB is a Document. Although stored as binary, when we query a database we obtain its representation as a JSON object.

Related documents can be stored in collections, similar to tables in relational databases. This is where the analogy ends though because we define what to consider "related documents".

MongoDB won't enforce a structure on the documents. For example, we could save this document to the Person collection:
```json
{
    "name": "Alice"
}
```

And then in the same collection, we could save a seemingly unrelated document with no shared properties or structure:
```json
{
    "latitude": 53.3498,
    "longitude": 6.2603
}
```
Here lies the novelty of NoSQL databases. We create meaning for our data and store it the way we consider best. The database won't impose any limitations.

### Mongoose Purpose
Although MongoDB won't impose a structure, applications usually manage data with one. We receive data and need to validate it to ensure what we received is what we need. We may also need to process the data in some way before saving it. This is where Mongoose kicks in.

Mongoose is an [NPM package](https://stackabuse.com/npm-install-specific-version-of-a-package/) for NodeJS applications. It allows defining schemas for our data to fit into, while also abstracting the access to MongoDB. This way we can ensure all saved documents share a structure and content required properties.

## Installing Mongoose and Creating the Person Schema
### Installing Mongoose
We can install `mongoose` with this command

```bash
npm install --save mongoose
```
`mongoose` will automatically include the `MongoDB` NPM module as well. You won't be using it directly yourself. It'll be handled by Mongoose.

To work with Mongoose, we'll want to import it into our scripts:
```js
import mongoose from "mongoose"
```
And then connect to the database with:
```js
mongoose.connect('mongodb://localhost/test', {
    useNewUrlParser: true,
    useUnifiedTopology: true
});
```

Since the database doesn't yet exist, one will be created. We'll be using the latest tool to parse the `connection string`, by setting the `useNewUrlParser` to `true` and we'll also use the latest MongoDB driver with `useUnifiedTopology` as `true`.

`mongoose.connect()` assumes the MongoDB server is running locally on the default port and without credentials. So you have to install MongoDB locally.

### Person Schema and Model
After the previous necessary explanations, we can now focus on writing our person schema and compiling a model from it.

A `schema` in `Mongoose` maps to a MongoDB collection and defines the format for all documents in that collection. All properties inside the schema must have an assigned `SchemaType`. For example, the name of our `Person` can be defined this way:
```js
const PersonSchema = new mongoose.Schema({
    name:  { type: String},
});
```

Or even simpler, like this:

```js
const PersonSchema = new mongoose.Schema({
    name:  String,
});
```

`String` is one of several `SchemaTypes` defined by `Mongoose`. You can find the rest in the [mongoose documentation](https://mongoosejs.com/docs/schematypes.html#what-is-a-schematype).

### Reference to Other Schemas
We can expect that all middle-sized applications will have more than one schema, and possibly those schemas will be linked in some way.

In our example, to represent a family tree we need to add two attributes to our schema:
```js
const PersonSchema = new mongoose.Schema({
    // ...
    mother: { type: mongoose.Schema.Types.ObjectId, ref: 'Person' },
    father: { type: mongoose.Schema.Types.ObjectId, ref: 'Person' },
});
```

A person can have a mother and a father. The way to represent this in `mongoose` is by saving the ID of the referenced document, `mongoose.Schema.Types.ObjectId`, not the object itself.

The `ref` property must be the name of the model we are referencing. We will see more about models later, but for now, is enough to know a schema relates to one model only, and 'Person' is the model of the `PersonSchema`.

Our case is a bit special because both mother and father will also contain persons, but the way to define these relations is the same in all cases.


### Built-In Validation

All SchemaTypes come with default built-in validation. We can define `limits` and other requirements depending on the selected `SchemaType`. To see some examples, let's add a `surname`, `yearBorn`, and `notes` to our `Person`:
```js
const PersonSchema = new mongoose.Schema({
    name: { type: String, index: true, required: true },
    surname: { type: String, index: true },
    yearBorn: { type: Number, min: -5000, max: (new Date).getFullYear() },
    notes: { type: String, minlength: 5 },
});
```

All built-in `SchemaTypes` can be required. In our case we want all persons to at least have a `name`. The `Number` type allows setting `min` and `max` values, which can even be calculated.

The `index` property will make `mongoose` create an index in the database. This facilitates the efficient execution of queries. Above, we defined the person's name and surname to be indexed. We will always search for persons by their names.

### Custom Validation
For now just read it, and don't take it too seriously. Just know that it is possible to define custom validation functions.

Built-in `SchemaTypes` allow for customization. This is especially useful when we have a property that can hold only certain values. Let's add the `photosURLs` property to our `Person`, an array of URLs their photos:
```js
const PersonSchema = new mongoose.Schema({
	// ...
	photosURLs: [{
		type: String,
		validate: {
			validator: function(value) {
				const urlPattern = /(http|https):\/\/(\w+:{0,1}\w*#)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%#!\-/]))?/;
				const urlRegExp = new RegExp(urlPattern);
				return value.match(urlRegExp);
			},
			message: props => `${props.value} is not a valid URL`
		}
	}],
});
```
`photosURLs` is just an array of Strings, `photosURLs: [String]`. What makes this property special is that we need custom validation to confirm the values added have the format of an internet URL.

The `validator()` function above uses a regular expression that matches typical internet URLs, which must begin with http(s)://.

If we need a more complex `SchemaType` we can create [our own one](https://mongoosejs.com/docs/customschematypes.html), but we do well to search if it's already available.

For example, the [mongoose-type-url](https://www.npmjs.com/package/mongoose-type-url) package adds a custom `SchemaType` that we could have used, `mongoose.SchemaTypes.Url`.


### Create the Model for a Schema
In order to start creating documents based on our Person schema, the last step is to compile a model based on the schema:
```js
const Person = mongoose.model('Person', PersonSchema);
```
The first argument will be the singular name of the collection we are referring to. This is the value we gave to the ref property of mother and father properties of our person. The second argument is the Schema we defined before.

The model() method makes a copy of all we defined on the schema. It also contains all Mongoose methods we will use to interact with the database. If we want to use this model outside the model's file. Then we also need to add this line.
```js
export default Person;
```

or simple do creation and exporting in one line:
```js
export default mongoose.model('Person', PersonSchema);
```
### How to Use the Model
The model we compiled in the last section contains all we need for interacting with the collection on the database. Let's now see how we would use our model for all CRUD operations.

#### Create Persons

We can create a person by simply doing:
```js
let alice = new Person({name: 'Alice'});
```
The name is the only `required` property. Let's create another person but using the virtual property this time:
```js
let bob = new Person({fullName: 'Bob Brown'});
```
Now that we have our first two persons, we can create a new one with all properties filled, including parents:
```js
let charles = new Person({
    fullName: 'Charles Brown',
    photosURLs: ['https://bit.ly/34Kvbsh'],
    yearBorn: 1922,
    notes: 'Famous blues singer and pianist. Parents not real.',
    mother: alice._id,
    father: bob._id,
});
```
All values for this last person are set to valid ones, as `validation` would fire an error as soon as this line is executed. For example, if we had set the first photo URL to something other than a link, we would get the error:
```js
ValidationError: Person validation failed: photosURLs.0: wrong_url is not a valid URL
```
As explained before, parents were completed with the IDs of the first two persons, instead of the objects. We have created three persons, but they are not stored in the database yet. Let's do that next:
```js
alice.save();
bob.save();
```
Operations that involve the database are asynchronous. If we want to wait for completion we can use `async/await` (if you don't know about async/await, please learn it):
```js
await charles.save();
```
Now that all persons are saved to the database, we can retrieve them back with the `find()` and `findOne()` methods.

### Retrieve One or More Persons

All find methods in Mongoose require an argument to filter the search. Let's get back to the last person we created:
```js
let dbCharles = await Person.findOne({name: 'Charles', surname: 'Brown'}).exec();
```
`findOne()` returns a query, so in order to get a result, we need to execute it with exec() and then wait for the result with await.

Because we attached a hook to the `findOne()` method to populate the person's parents, we could now access them directly:
```js
console.log(dbCharles.mother.fullName);
```
In our case, we know the query will return only one result, but even if more than one person matches the filter, only the first result will be returned.

We can get more than one result if we use the `find()` method:
```js
let all = await Person.find({}).exec();
```
We will get back an array we can iterate over.

### Update Persons
If we already have a person, either because we just created it or retrieved it, we can update and save changes by doing:
```js
alice.surname = 'Adams';
charles.photosURLs.push('https://bit.ly/2QJCnMV');
await alice.save();
await charles.save();
```
Because both persons already exist on the database, Mongoose will send an update command only with the fields changed, not the whole document.

There are many other ways to do update, like `model.updateOne()`, `model.updateMany():
```js
alice.surname = 'Adams';
charles.photosURLs.push('https://bit.ly/2QJCnMV');
await person.updateOne(
    { _id: alice._id },
    { $set: alice },
    { runValidators: true }
)

await person.updateOne(
    { _id: charles._id },
    { $set: charles },
    { runValidators: true }
)
```
### Delete Persons
Like retrieval, deletion can be done for one or many persons. Models have static `deleteOne()`, `deleteMany()`, `findOneAndDelete()`, `findByIdAndDelete()` functions for removing all documents matching the filter. Let's do:

* `deleteOne()` method to delete only the first document that matches the condition you specify. Let's demo an example of how to delete the first document that has `name` equal to Alice

      await Person.deleteOne({name: 'Alice'});

* If you plan on deleting multiple documents based on one or multiple conditions you'll want to use the `deleteMany()` function. Let's look at an example of how we'd use it to delete all the documents with the `name` Charles.
```js
await Person.deleteMany({name: 'Charles'});
```
* NOTE: if you execute `deleleMany()` with no filter, then your collection will be empty.

* `findOneAndDelete()` command is very similar to the above `deleteOne()` command with a few more options. 
   
      await Person.findOneAndDelete({name: 'Alice'});

* `deleteById()`, it delete by id which is an extremely common use case. 
```js
await Person.deleteById(charles._id);
```

We'll do practical implementation next blog