---
sidebar_position: 6
id: crud
title: CRUD in Express
# description: 
slug: crud
---

## What is CRUD?
[CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) is an acronym for Create, Read, Update and Delete. It is a set of operations we get servers to execute (POST, GET, PUT and DELETE respectively). This is what each operation does:

* Create (POST) — Make something
* Read (GET) — Get something
* Update (PUT/PATCH) — Change something
* Delete (DELETE) —Remove something

Great. Let's take a look at how these operations work.

## What we're building
We're going to build a CRUD of Book that allows you to keep track of data related to the books. For the sake of simplicity, I won't be using a database, so you don't need experience using one. We will use a simple JavaScript array to store our data instead.

## Getting started
Start by creating a folder for this project. Feel free to call it anything you want. Once you navigate into it, run the `npm init` command.

This command creates a package.json file which helps you manage dependencies that we install later. Now do some changes to `package.json` file and create `index.js` file, as we did in [5. Basic Code](https://github.com/mrizwanashiq/learning-express-js/wiki/5.-Basic-Code)

## Adding Books - CREATE
The CREATE operation is performed when you want to save data (into database), and to do this POST request is sent to the server. In Express, we handle a POST request with the post method:

```js
app.post(path, callback)
```
The first argument, path, is the path of the GET request. It's anything that comes after your domain name.

When we're visiting localhost:3000, our browsers are actually looking for `localhost:3000/`. The path argument, in this case, is `/`.

The second argument is a callback function that tells the server what to do when the path is matched. It takes in two arguments, a request object and a response object:

```js
app.post('/', function (request, response) {  
    // do something here
})
```
So, let's write a post method to save data:
```js
// Importing package
import express from 'express';
import bodyParser from 'body-parser';
import cors from 'cors';

const app = express();
const port = 3000;

// Where we will keep books
let books = [];

// Configuring middlewares
app.use(cors());
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

// POST API
app.post('/book', (req, res) => {
    // We will be coding here
});

app.listen(port, () => console.log(`Hello world app listening on port ${port}!`));
```

As you can see, we can configure body-parser by importing it and passing it to the `app.use` method, which enables it as middleware to the Express app instance.

We will be using the books array to store our collection of books, simulating a database.

There are a few types of HTTP request body types. For example, `application/x-www-form-urlencoded` is the default body type for forms, whereas `application/json` is something we'd use when requesting a resource using jQuery or the backend REST client.

What the `body-parser` middleware will be doing is grabbing the HTTP body, decoding the information, and appending it to the `req.body`. From there, we can easily retrieve the information from the form - in our case, a book's information.

We're sending this data inside request's body 

```json
{
    "name": "The Lord of the Rings",
    "author": "J.R.R. Tolkien",
    "publisher": "Allen & Unwin",
}
```

Inside the `app.post` method let's add the book to the book array:
```js
app.post('/book', (req, res) => {
    const book = req.body;

    // here length of books' array will be the id of that book
    book.id = books.length + 1;

    // Output the book to the console for debugging
    console.log(book);
    books.push(book);

    res.send('Book is added to the database');
});
```

### Getting All Books - READ
The READ operation is performed by browsers whenever you visit a webpage. Under the hood, browsers send a GET request to the server to perform a READ operation. The reason we see the “cannot get /” error is that we have yet to send anything back to the browser from our server.

In Express, we handle a GET request with the get method:

```js
app.get(path, callback)
```
Now let's create an endpoint to get all the books from the API:

```js
app.get('/book', (req, res) => {
    res.json(books);
});
```

Restart the server. If the server is already running press `Ctrl + C` to stop it first. Add some books and open `http://localhost:3000/books` in your browser. You should see a JSON response with all the books that you've added.

In this case, the JSON response will be like
```json
[
    {
        "id": 1,
        "name": "The Lord of the Rings",
        "author": "J.R.R. Tolkien",
        "publisher": "Allen & Unwin",
    }
]
```

### Retrieving a Book by ID

If we'd like to display a specific book to the user, we'll need a way to retrieve it from the database (or the array, in our case). This is always done by a key specific to that entity. In most cases, each entity has a unique id that helps us identify them.

In our case, each book has an id that is unique by nature, so there's no need for another id value.

This is typically done by parsing the URL parameter for an id and searching for the book with the corresponding id.

For example, if the id is 1 the URL would look like, `http://localhost:3000/book/1`:
```js
app.get('/book/:id', (req, res) => {
    // Reading ID from the URL
    const id = parseInt(req.params.id);

    // Searching books for the id
    for (let book of books) {
        if (book.id === id) {
            res.json(book);
            return;
        }
    }

    // Sending 404 when not found something is a good practice
    res.status(404).send('Book not found');
});
```

### Editing Books - UPDATE
Very similar to deleting entities, updating them requires us to snatch a specific one, based on the id and then send either a `PATCH` or `PUT` HTTP call with the new information.

First I'll do `PUT`, where I'll replace the book's data with the new one
```js
app.put('/book/:id', (req, res) => {
    // Reading id from the URL
    const id = parseInt(req.params.id);
    const book = req.body;
    book.id = id

    // Remove item from the books array
    for (let i = 0; i < books.length; i++) {
        if (book[i].id === id) {
            books[i] = book;
        }
    }

    res.send('Book is replace');
});
```

Now `PATCH`, here I'll update the book's data
```js
app.patch('/book/:id', (req, res) => {
    // Reading id from the URL
    const id = parseInt(req.params.id);
    const book = req.body;
    book.id = id

    // Remove item from the books array
    for (let i = 0; i < books.length; i++) {
        if (book[i].id === id) {
            books[i] = {...book[i], ...book};
        }
    }

    res.send('Book is update');
});
```

### Deleting Books - DELETE
When deleting entities, we typically delete them one by one to avoid big accidental data loss. To delete items, we use the HTTP `DELETE` method and specify a book using its id, just like how we retrieved it:
```js
app.delete('/book/:id', (req, res) => {
    // Reading id from the URL
    const id = parseInt(req.params.id);

    // Remove item from the books array
    books = books.filter(i => {
        if (i.id !== id) {
            return true;
        }
        return false;
    });

    res.send('Book is deleted');
});
```
 We are using the `app.delete` method to accept `DELETE` requests. We have also used the array `filter` method to filter out the book with the relevant id to remove it from the array.

That's how easy it is to build a CRUD using Node.js and Express. 

## Code

You can download the related code from [here](https://github.com/mrizwanashiq/learning-express-js/tree/example/crud-code)

